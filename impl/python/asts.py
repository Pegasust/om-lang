# DO NOT EDIT THIS FILE

from typing import Optional, Callable

from tokens import Token, Coord
import symbols

i4 = " " * 4


class AST:
    def pprint(self, indent: str):
        assert False, f"AST.pprint() not implemented for {type(self)}"

    def __eq__(self, other):
        return self.assert_equal(other, lambda a, b: True)

    def __repr__(self) -> str:
        assert False, f"AST.__repr__() not implemented for {type(self)}"

    def assert_equal(self, other: "AST", fn: Callable[["AST", "AST"], bool]) -> bool:
        assert False, f"AST.assert_equal() not implemented for {type(self)}"


class Program(AST):
    def __init__(self, decls: list["FuncDecl"]):
        self.decls: list["FuncDecl"] = decls

    def pprint(self, indent: str):
        print(indent + "Program")
        for decl in self.decls:
            decl.pprint(indent + i4)

    def __repr__(self):
        return f"Program({self.decls})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, Program)
        assert fn(self, other)
        assert len(self.decls) == len(other.decls)
        for i in range(len(self.decls)):
            self.decls[i].assert_equal(other.decls[i], fn)
        return True


class Id(AST):
    def __init__(self, token: Token):
        self.token = token
        self.symbol: symbols.Symbol = symbols.PhonySymbol()
        self.semantic_type: symbols.Type = symbols.PhonyType()

    def pprint(self, indent: str):
        print(indent + f"Id({self.token}")

    def __repr__(self):
        return f"Id({self.token.__repr__()}; {self.symbol.offset})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, Id)
        assert fn(self, other)
        assert self.token == other.token
        return True


class Type(AST):
    semantic_type: symbols.Type = symbols.PhonyType()


class Decl(AST):
    semantic_type: symbols.Type = symbols.PhonyType()


class VarDecl(Decl):
    def __init__(self, id: Id, type: Type):
        self.id = id
        self.type_ast: Type = type
        self.semantic_type: symbols.Type = symbols.PhonyType()

    def pprint(self, indent: str):
        print(indent + "VarDecl")
        self.id.pprint(indent + i4)
        self.type_ast.pprint(indent + i4)

    def __repr__(self):
        return f"VarDecl({self.id}, {self.type_ast})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, VarDecl)
        assert fn(self, other)
        assert self.id.assert_equal(other.id, fn)
        assert self.type_ast.assert_equal(other.type_ast, fn)
        return True


class ParamDecl(Decl):
    def __init__(self, id: Id, type: Type):
        self.id = id
        self.type_ast: Type = type
        self.semantic_type: symbols.Type = symbols.PhonyType()

    def pprint(self, indent: str):
        print(indent + "ParamDecl")
        self.id.pprint(indent + i4)
        self.type_ast.pprint(indent + i4)

    def __repr__(self):
        return f"ParamDecl({self.id}, {self.type_ast})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, ParamDecl)
        assert fn(self, other)
        assert self.id.assert_equal(other.id, fn)
        assert self.type_ast.assert_equal(other.type_ast, fn)
        return True


class IntType(Type):
    def __init__(self, token: Token):
        self.token: Token = token

    def pprint(self, indent: str):
        print(indent + "IntType")

    def __repr__(self):
        return f"IntType({self.token.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, IntType)
        assert fn(self, other)
        assert self.token == other.token
        return True


class BoolType(Type):
    def __init__(self, token: Token):
        self.token: Token = token

    def pprint(self, indent: str):
        print(indent + "BoolType")

    def __repr__(self):
        return f"BoolType({self.token.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        return isinstance(other, BoolType)
        assert fn(self, other)
        assert self.token == other.token
        return True


class ArrayType(Type):
    def __init__(self, size: Optional["Expr"], type: Type):
        self.size: Optional["Expr"] = size
        self.element_type_ast: Type = type

    def pprint(self, indent: str):
        print(indent + "ArrayType")
        if self.size is not None:
            self.size.pprint(indent + i4)
        self.element_type_ast.pprint(indent + i4)

    def __repr__(self):
        return f"ArrayType({self.size}, {self.element_type_ast})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, ArrayType)
        assert fn(self, other)
        assert (self.size is None and other.size is None) or (
            self.size is not None
            and other.size is not None
            and self.size.assert_equal(other.size, fn)
        )
        assert self.element_type_ast.assert_equal(other.element_type_ast, fn)
        return True


class Stmt(AST):
    pass


class PrintStmt(Stmt):
    def __init__(self, expr: "Expr"):
        self.expr: Expr = expr

    def pprint(self, indent: str):
        print(indent + "Print")
        self.expr.pprint(indent + i4)

    def __repr__(self):
        return f"PrintStmt({self.expr})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, PrintStmt)
        assert fn(self, other)
        assert self.expr.assert_equal(other.expr, fn)
        return True


class CompoundStmt(Stmt):
    def __init__(
        self,
        decls: list[VarDecl],
        stmts: list[Stmt],
        return_stmt: Optional["ReturnStmt"],
    ):
        self.decls: list[VarDecl] = decls
        self.stmts: list[Stmt] = stmts
        self.return_stmt: Optional[ReturnStmt] = return_stmt
        self.local_scope: symbols.Scope = symbols.PhonyScope()

    def pprint(self, indent: str):
        print(indent + "CompoundStmt")
        for decl in self.decls:
            decl.pprint(indent + i4)
        for stmt in self.stmts:
            stmt.pprint(indent + i4)
        if self.return_stmt is not None:
            self.return_stmt.pprint(indent + i4)

    def __repr__(self):
        return f"CompoundStmt({self.decls}, {self.stmts}, {self.return_stmt})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, CompoundStmt)
        assert fn(self, other)
        assert len(self.decls) == len(other.decls)
        for i in range(len(self.decls)):
            self.decls[i].assert_equal(other.decls[i], fn)
        assert len(self.stmts) == len(other.stmts)
        for i in range(len(self.stmts)):
            self.stmts[i].assert_equal(other.stmts[i], fn)
        assert (self.return_stmt is None and other.return_stmt is None) or (
            self.return_stmt is not None
            and other.return_stmt is not None
            and self.return_stmt.assert_equal(other.return_stmt, fn)
        )
        return True


class FuncDecl(AST):
    def __init__(
        self,
        id: Id,
        params: list[ParamDecl],
        ret_type_ast: Optional[Type],
        body: CompoundStmt,
    ):
        self.id = id
        self.params: list[ParamDecl] = params
        self.ret_type_ast: Optional[Type] = ret_type_ast
        self.body: CompoundStmt = body
        self.func_scope: symbols.Scope = symbols.PhonyScope()

    def pprint(self, indent: str):
        print(indent + "FuncDecl")
        self.id.pprint(indent + i4)
        for param in self.params:
            param.pprint(indent + i4)
        if self.ret_type_ast is not None:
            self.ret_type_ast.pprint(indent + i4)
        self.body.pprint(indent + i4)

    def __repr__(self):
        return f"FuncDecl({self.id}, {self.params}, {self.ret_type_ast}, {self.body}, {self.id.symbol.get_type()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, FuncDecl)
        assert fn(self, other)
        assert self.id.assert_equal(other.id, fn)
        assert len(self.params) == len(other.params)
        for i in range(len(self.params)):
            self.params[i].assert_equal(other.params[i], fn)
        assert (self.ret_type_ast is None and other.ret_type_ast is None) or (
            self.ret_type_ast is not None
            and other.ret_type_ast is not None
            and self.ret_type_ast.assert_equal(other.ret_type_ast, fn)
        )
        assert self.body.assert_equal(other.body, fn)
        return True


class Expr(AST):
    semantic_type: symbols.Type = symbols.PhonyType()


class CallExpr(Expr):
    def __init__(self, fn: Expr, args: list[Expr], coord: Coord):
        self.fn: Expr = fn
        self.args: list[Expr] = args
        self.coord: Coord = coord

    def pprint(self, indent: str):
        print(indent + "CallExpr")
        self.fn.pprint(indent + i4)
        for arg in self.args:
            arg.pprint(indent + i4)

    def __repr__(self):
        return f"CallExpr({self.fn}, {self.args}, {self.coord.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, CallExpr)
        assert fn(self, other)
        assert self.fn.assert_equal(other.fn, fn)
        assert len(self.args) == len(other.args)
        for i in range(len(self.args)):
            self.args[i].assert_equal(other.args[i], fn)
        return True


class AssignStmt(Stmt):
    def __init__(self, lhs: Expr, rhs: Expr, token):
        self.lhs: Expr = lhs
        self.rhs: Expr = rhs
        self.token: Token = token

    def pprint(self, indent: str):
        print(indent + "AssignStmt")
        self.lhs.pprint(indent + i4)
        self.rhs.pprint(indent + i4)

    def __repr__(self):
        return f"AssignStmt({self.lhs}, {self.rhs}, {self.token.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, AssignStmt)
        assert fn(self, other)
        assert self.lhs.assert_equal(other.lhs, fn)
        assert self.rhs.assert_equal(other.rhs, fn)
        return True


class IfStmt(Stmt):
    def __init__(
        self,
        expr: Expr,
        thenStmt: CompoundStmt,
        elseStmt: Optional[CompoundStmt],
        coord: Coord,
    ):
        self.expr: Expr = expr
        self.thenStmt: CompoundStmt = thenStmt
        self.elseStmt: Optional[CompoundStmt] = elseStmt
        self.coord: Coord = coord

    def pprint(self, indent: str):
        print(indent + "IfStmt")
        self.expr.pprint(indent + i4)
        self.thenStmt.pprint(indent + i4)
        if self.elseStmt is not None:
            self.elseStmt.pprint(indent + i4)

    def __repr__(self):
        return f"IfStmt({self.expr}, {self.thenStmt}, {self.elseStmt}, {self.coord.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, IfStmt)
        assert fn(self, other)
        assert self.expr.assert_equal(other.expr, fn)
        assert self.thenStmt.assert_equal(other.thenStmt, fn)
        assert (self.elseStmt is None and other.elseStmt is None) or (
            self.elseStmt is not None
            and other.elseStmt is not None
            and self.elseStmt.assert_equal(other.elseStmt, fn)
        )
        return True


class WhileStmt(Stmt):
    def __init__(self, expr: Expr, stmt: CompoundStmt, coord: Coord):
        self.expr: Expr = expr
        self.stmt: CompoundStmt = stmt
        self.coord: Coord = coord

    def pprint(self, indent: str):
        print(indent + "WhileStmt")
        self.expr.pprint(indent + i4)
        self.stmt.pprint(indent + i4)

    def __repr__(self):
        return f"WhileStmt({self.expr}, {self.stmt}, {self.coord.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, WhileStmt)
        assert fn(self, other)
        assert self.expr.assert_equal(other.expr, fn)
        assert self.stmt.assert_equal(other.stmt, fn)
        return True


class CallStmt(Stmt):
    def __init__(self, call: CallExpr):
        self.call: CallExpr = call

    def pprint(self, indent: str):
        print(indent + "CallStmt")
        self.call.pprint(indent + i4)

    def __repr__(self):
        return f"CallStmt({self.call})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, CallStmt)
        assert self.call.assert_equal(other.call, fn)
        return True


class ReturnStmt(Stmt):
    def __init__(self, expr: Optional[Expr], coord: Coord):
        self.expr: Optional[Expr] = expr
        self.coord: Coord = coord
        self.enclosing_scope: symbols.Scope = symbols.PhonyScope()

    def pprint(self, indent: str):
        print(indent + "ReturnStmt")
        if self.expr is not None:
            self.expr.pprint(indent + i4)

    def __repr__(self):
        return f"ReturnStmt({self.expr}, {self.coord.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, ReturnStmt)
        assert fn(self, other)
        assert (self.expr is None and other.expr is None) or (
            self.expr is not None
            and other.expr is not None
            and self.expr.assert_equal(other.expr, fn)
        )
        return True


class BinaryOp(Expr):
    def __init__(self, op: Token, left: Expr, right: Expr):
        self.op: Token = op
        self.left: Expr = left
        self.right: Expr = right

    def pprint(self, indent: str):
        print(indent + f"BinaryOp({self.op})")
        self.left.pprint(indent + i4)
        self.right.pprint(indent + i4)

    def __repr__(self):
        return f"BinaryOp({self.op}, {self.left}, {self.right})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, BinaryOp)
        assert fn(self, other)
        assert self.op == other.op
        assert self.left.assert_equal(other.left, fn)
        assert self.right.assert_equal(other.right, fn)
        return True


class UnaryOp(Expr):
    def __init__(self, op: Token, expr: Expr):
        self.op: Token = op
        self.expr: Expr = expr

    def pprint(self, indent: str):
        print(indent + f"UnaryOp({self.op})")
        self.expr.pprint(indent + i4)

    def __repr__(self):
        return f"UnaryOp({self.op}, {self.expr})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, UnaryOp)
        assert fn(self, other)
        assert self.op == other.op
        assert self.expr.assert_equal(other.expr, fn)
        return True


class ArrayCell(Expr):
    def __init__(self, arr: Expr, idx: Expr, coord: Coord):
        self.arr: Expr = arr
        self.idx: Expr = idx
        self.coord: Coord = coord

    def pprint(self, indent: str):
        print(indent + "ArrayCell")
        self.arr.pprint(indent + i4)
        self.idx.pprint(indent + i4)

    def __repr__(self):
        return f"ArrayCell({self.arr}, {self.idx}, {self.coord.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, ArrayCell)
        assert fn(self, other)
        assert self.arr.assert_equal(other.arr, fn)
        assert self.idx.assert_equal(other.idx, fn)
        return True


class IntLiteral(Expr):
    def __init__(self, token: Token):
        self.token: Token = token

    def pprint(self, indent: str):
        print(indent + f"IntLiteral({self.token})")

    def __repr__(self):
        return f"IntLiteral({self.token.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, IntLiteral)
        assert fn(self, other)
        assert self.token == other.token
        return True


class TrueLiteral(Expr):
    def __init__(self, token: Token):
        self.token: Token = token

    def pprint(self, indent: str):
        print(indent + "TrueLiteral")

    def __repr__(self):
        return f"TrueLiteral({self.token.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, TrueLiteral)
        assert fn(self, other)
        assert self.token == other.token
        return True


class FalseLiteral(Expr):
    def __init__(self, token: Token):
        self.token: Token = token

    def pprint(self, indent: str):
        print(indent + "FalseLiteral")

    def __repr__(self):
        return f"FalseLiteral({self.token.__repr__()})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, FalseLiteral)
        assert fn(self, other)
        assert self.token == other.token
        return True


class IdExpr(Expr):
    def __init__(self, id: Id):
        self.id = id

    def pprint(self, indent: str):
        print(indent + f"IdExpr")
        self.id.pprint(indent + i4)

    def __repr__(self):
        return f"IdExpr({self.id})"

    def assert_equal(self, other: AST, fn: Callable[[AST, AST], bool]):
        assert isinstance(other, IdExpr)
        assert fn(self, other)
        assert self.id.assert_equal(other.id, fn)
        return True
